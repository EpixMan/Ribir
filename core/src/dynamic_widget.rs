use crate::prelude::{widget_tree::WidgetTree, *};
use rxrust::ops::box_it::LocalBoxOp;
use smallvec::{smallvec, SmallVec};

/// Dynamic widgets generate by expression , `expr` hold the expression and wrap
/// as a widget generate callback. The return type hint the origin expression
/// info, maybe [`SingleConsumer`]! or [`MultiConsumer`]!
#[derive(Declare)]
pub struct ExprWidget<E> {
  pub(crate) expr: E,
  #[declare(convert = custom)]
  pub(crate) upstream: LocalBoxOp<'static, ChangeScope, ()>,
}

/// ConstExprWidget is convert from uer declared  `ExprWidget` which but its
/// expression not following anything.
#[derive(Declare)]
pub struct ConstExprWidget<W> {
  pub(crate) expr: W,
}

/// Generator is a virtual child used in `widget!`, which use to generate
/// dynamic widgets and provide ability to keep them up to date in their
/// lifetime.
pub(crate) struct Generator {
  pub(crate) info: GeneratorInfo,
  pub(crate) expr: Box<dyn FnMut(&mut BuildCtx) -> DynamicWidget>,
  pub(crate) _upstream_handle: SubscriptionGuard<Box<dyn SubscriptionLike>>,
}

/// The unique id of widget generator in application
#[derive(Clone, Copy, Default, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub(crate) struct GeneratorID(usize);

/// the information of a widget generated by `ExprWidget`.
pub(crate) enum DynamicWidgetInfo {
  /// ExprWidget generate single result,  and have static children. The depth
  /// describe the count from first dynamic widget to the static child.
  SingleDynWithChild { gen_root: WidgetId, depth: usize },
  /// Whole subtree is generated by `ExprWidget`.
  WholeSubtree(SmallVec<[WidgetId; 1]>),
}
pub struct GeneratorInfo {
  id: GeneratorID,
  /// The parent of the generator.
  parent: Option<WidgetId>,
  /// widget generated by the generator.
  gen_dyn_widgets: DynamicWidgetInfo,
}

impl<R> ExprWidgetBuilder<R> {
  pub fn upstream(
    mut self,
    stream: impl LocalObservable<'static, Item = ChangeScope, Err = ()> + 'static,
  ) -> Self {
    self.upstream = Some(stream.box_it());
    self
  }
}

impl GeneratorInfo {
  pub(crate) fn new(
    id: GeneratorID,
    parent: Option<WidgetId>,
    road_sign: WidgetId,
    has_child: bool,
  ) -> Self {
    let gen_dyn_widgets = if has_child {
      DynamicWidgetInfo::SingleDynWithChild { gen_root: road_sign, depth: 1 }
    } else {
      DynamicWidgetInfo::WholeSubtree(smallvec![road_sign])
    };
    GeneratorInfo { id, parent, gen_dyn_widgets }
  }

  pub(crate) fn parent(&self) -> Option<WidgetId> { self.parent }

  pub(crate) fn generate_id(&self) -> GeneratorID { self.id }
}

pub enum DynamicWidget {
  Single(Option<Widget>),
  Multi(Box<dyn Iterator<Item = Widget>>),
}

pub trait IntoDynWidget<M: ?Sized> {
  fn into_dyn_widget(self) -> DynamicWidget;
}

// mark the expr of `ExprWidget` only generate at most one widget.
pub trait SingleDyn<M: ?Sized>: IntoDynWidget<M> {}
impl<W, M: ?Sized> IntoDynWidget<&M> for W
where
  W: IntoWidget<M>,
{
  #[inline]
  fn into_dyn_widget(self) -> DynamicWidget { DynamicWidget::Single(Some(self.into_widget())) }
}

impl<I, M> IntoDynWidget<dyn Iterator<Item = M>> for I
where
  M: ?Sized,
  I: IntoIterator + 'static,
  I::Item: IntoWidget<M>,
{
  #[inline]
  fn into_dyn_widget(self) -> DynamicWidget {
    DynamicWidget::Multi(Box::new(self.into_iter().map(|w| w.into_widget())))
  }
}

impl<W, M: ?Sized> SingleDyn<&M> for W where W: IntoWidget<M> {}
impl<W, M: ?Sized> SingleDyn<dyn Iterator<Item = M>> for Option<W> where W: IntoWidget<M> +'static{}

impl<E, R> ExprWidget<E>
where
  E: FnMut(&mut BuildCtx) -> R + 'static,
{
  /// Only if `ExprWidget` generate at most one widget can as a normal widget,
  /// otherwise it must been children of multi child widget.
  #[inline]
  pub fn into_widget<M: ?Sized>(self) -> Widget
  where
    R: SingleDyn<M>,
  {
    self.into_child()
  }

  #[inline]
  pub fn into_child<M: ?Sized>(self) -> Widget
  where
    R: IntoDynWidget<M>,
  {
    let Self { mut expr, upstream } = self;

    Widget {
      node: Some(WidgetNode::Dynamic(ExprWidget {
        expr: Box::new(move |ctx| expr(ctx).into_dyn_widget()),
        upstream,
      })),
      children: Children::None,
    }
  }
}

impl<W>  ConstExprWidget<W> {
  #[inline]
  pub fn into_widget< M: ?Sized>(self) -> Widget where W: IntoWidget<M>, { self.expr.into_widget() }
}

impl Generator {
  pub(crate) fn info(&self) -> &GeneratorInfo { &self.info }

  pub fn refresh(&mut self, tree: &mut WidgetTree) {
    let parent = self.info.parent();
    let gen_result = &mut self.info.gen_dyn_widgets;
    let mut ctx = BuildCtx::new(parent, tree);
    let new_gen = (self.expr)(&mut ctx);

    match (gen_result, new_gen) {
      (
        &mut DynamicWidgetInfo::SingleDynWithChild { gen_root, depth },
        DynamicWidget::Single(w),
      ) => {
        self.refresh_single_with_child(gen_root, w, depth, tree);
      }
      (DynamicWidgetInfo::WholeSubtree(ref old_widgets), result) => {
        let new_widgets = match result {
          DynamicWidget::Single(w) => {
            let w = w.unwrap_or_else(|| Void.into_widget());
            tree.replace_children(old_widgets, std::iter::once(w))
          }
          DynamicWidget::Multi(m) => tree.replace_children(old_widgets, m),
        };

        new_widgets.iter().for_each(|n| tree.mark_dirty(*n));
        self.info.gen_dyn_widgets = DynamicWidgetInfo::WholeSubtree(new_widgets);
      }
      _ => unreachable!("generator not match its generate"),
    }
  }

  fn refresh_single_with_child(
    &mut self,
    mut old_gen_root: WidgetId,
    widget: Option<Widget>,
    depth: usize,
    tree: &mut WidgetTree,
  ) {
    let mut new_gen_root = widget
      .and_then(|w| w.into_subtree(self.info().parent, tree))
      // gen root at least have a void widget as road sign.
      .unwrap_or_else(|| tree.empty_node());

    let declare_child_parent = single_down(old_gen_root, tree, depth as isize - 1);
    let (new_leaf, down_level) = down_to_leaf(new_gen_root, tree);
    let new_depth = down_level + 1;
    if let Some(declare_child_parent) = declare_child_parent {
      let (tree1, tree2) = unsafe { tree.split_tree() };
      declare_child_parent
        .children(tree1)
        .for_each(|c| new_leaf.append(c, tree2));
    }

    let mut old = Some(old_gen_root);
    let mut new = Some(new_gen_root);
    let mut replace_depth = 0;
    loop {
      if replace_depth >= depth {
        break;
      }
      let (o, n) = match (old, new) {
        (Some(o), Some(n)) => (o, n),
        _ => break,
      };

      // not same key
      if n
        .key(tree)
        .map_or(true, |new_key| Some(new_key) != o.key(tree))
      {
        break;
      }

      tree.swap_node_data(o, n);
      o.swap(n, tree);

      old = o.single_child(tree);
      new = n.single_child(tree);
      replace_depth += 1;
    }

    if replace_depth > 0 {
      std::mem::swap(&mut old_gen_root, &mut new_gen_root);
    } else {
      old_gen_root.insert_after(new_gen_root, tree);
    }

    let root = tree.root();
    old_gen_root.remove_subtree(tree);

    if let Some(new_from) = single_on_mounted(new_gen_root, replace_depth, false, tree) {
      single_on_mounted(new_from, new_depth - replace_depth, true, tree);
    }
    if old_gen_root == root {
      tree.set_root_id(new_gen_root);
    }

    self.info.gen_dyn_widgets = DynamicWidgetInfo::SingleDynWithChild {
      gen_root: new_gen_root,
      depth: new_depth,
    };
    tree.mark_dirty(new_gen_root);
  }
}

fn single_down(id: WidgetId, tree: &WidgetTree, mut down_level: isize) -> Option<WidgetId> {
  let mut res = Some(id);
  while down_level > 0 {
    down_level -= 1;
    res = res.unwrap().single_child(tree);
  }
  res
}

fn down_to_leaf(id: WidgetId, tree: &WidgetTree) -> (WidgetId, usize) {
  let mut leaf = id;
  let mut depth = 0;
  while let Some(c) = leaf.single_child(tree) {
    leaf = c;
    depth += 1;
  }
  (leaf, depth)
}

fn single_on_mounted(
  from: WidgetId,
  mut level: usize,
  brand_new: bool,
  tree: &mut WidgetTree,
) -> Option<WidgetId> {
  let mut next = Some(from);
  while level > 0 {
    let c = next.unwrap();
    c.on_mounted(tree, brand_new);
    next = c.single_child(tree);

    level -= 1;
  }
  next
}

impl GeneratorID {
  #[inline]
  pub(crate) fn next_id(self) -> Self { Self(self.0 + 1) }
}

#[cfg(test)]
mod tests {
  use crate::prelude::*;
  use crate::widget::{widget_tree::WidgetTree, IntoStateful};

  #[test]
  fn expr_widget_as_root() {
    let size = Size::zero().into_stateful();
    let w = widget! {
      track { size: size.clone() }
      ExprWidget {
        expr: SizedBox { size: size.clone() },
        Void {}
      }
    };
    let mut tree = WidgetTree::new(w, <_>::default());
    tree.tree_repair();
    let ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(ids.len(), 2);
    {
      *size.state_ref() = Size::new(1., 1.);
    }
    tree.tree_repair();
    let new_ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(new_ids.len(), 2);

    assert_eq!(ids[1], new_ids[1]);
  }

  #[test]
  fn expr_widget_with_declare_child() {
    let size = Size::zero().into_stateful();
    let w = widget! {
      track { size: size.clone() }
      SizedBox {
        size: Size::zero(),
        ExprWidget {
          expr: SizedBox { size: size.clone() },
          Void {}
        }
      }
    };
    let mut tree = WidgetTree::new(w, <_>::default());
    tree.tree_repair();
    let ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(ids.len(), 3);
    {
      *size.state_ref() = Size::new(1., 1.);
    }
    tree.tree_repair();
    let new_ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(new_ids.len(), 3);

    assert_eq!(ids[0], new_ids[0]);
    assert_eq!(ids[2], new_ids[2]);
  }

  #[test]
  fn key_track() {
    let trigger = true.into_stateful();
    let w = widget! {
      track { trigger: trigger.clone() }
      ExprWidget {
        expr: trigger.then(||{
          widget!{
            Row {
              key: 4,
              Void { key: 1 }
              Void { key: 2 }
              Void { key: 3 }
              Row {
                Void { key: 1 }
                Void { key: 2 }
                Void { key: 3 }
              }
            }
          }
        }),
      }
    };
    let mut tree = WidgetTree::new(w, <_>::default());
    tree.tree_repair();
    let ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(ids.len(), 8);
    {
      *trigger.state_ref() = true;
    }
    tree.tree_repair();
    let new_ids = tree.root().descendants(&tree).collect::<Vec<_>>();
    assert_eq!(new_ids.len(), 8);
    // the subtree of inner row will not be tracked.
    assert_eq!(ids[0..4], new_ids[0..4]);
    assert_ne!(ids[4], new_ids[4]);
  }
}
